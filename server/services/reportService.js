import Patient from '../models/patient.js';
import Treatment from '../models/treatment.js';
import LabTest from '../models/labTest.js';
import puppeteer from 'puppeteer'; 

// PDF GENERATION HTML HELPER 
const createReportHtml = (reportData, filters) => {
    const tsr = reportData.TSR_Analysis.map(item => 
        `<li>${item._id}: <strong>${item.count}</strong> cases</li>`
    ).join('');

    const trends = reportData.Notification_Trend.map(item => 
        `<tr><td>Q${item._id.quarter} ${item._id.year}</td><td>${item.count}</td></tr>`
    ).join('');

    return `
        <html>
        <head>
            <title>TB Surveillance Report</title>
            <style>
                body { font-family: 'Arial', sans-serif; margin: 40px; line-height: 1.5; }
                h1 { color: #34495E; border-bottom: 3px solid #3498DB; padding-bottom: 8px; margin-bottom: 20px; }
                h2 { color: #2C3E50; margin-top: 30px; font-size: 1.4em; }
                p, li { font-size: 12pt; }
                table { width: 100%; border-collapse: collapse; margin-top: 15px; }
                th, td { border: 1px solid #ddd; padding: 10px; text-align: left; }
                th { background-color: #ECF0F1; color: #333; }
                .meta { margin-bottom: 25px; border: 1px dashed #ccc; padding: 15px; }
            </style>
        </head>
        <body>
            <h1>Quarterly TB Public Health Surveillance Report</h1>
            <div class="meta">
                <p><strong>Generated By:</strong> Health Informatics System</p>
                <p><strong>Generated On:</strong> ${new Date().toLocaleDateString()} at ${new Date().toLocaleTimeString()}</p>
                <p><strong>Filters Applied:</strong> Date Range: ${filters.startDate || 'All Time'} to ${filters.endDate || 'Current'}</p>
            </div>
            <h2>1. Treatment Success Rate (TSR) Analysis</h2>
            <p>Breakdown of final treatment outcomes for the cohort:</p>
            <ul>${tsr}</ul>
            <h2>2. New Case Notifications Trend</h2>
            <p>New TB cases registered, grouped by quarter:</p>
            <table>
                <thead>
                    <tr><th>Period</th><th>New Cases Notified</th></tr>
                </thead>
                <tbody>
                    ${trends}
                </tbody>
            </table>
            <h2>3. Relapse Summary</h2>
            <p>Total Confirmed Relapse Cases Recorded in Period: <strong>${reportData.Relapse_Count}</strong></p>
        </body>
        </html>
    `;
};


// Generates the PDF buffer using Puppeteer with robust error handling.
const generatePDFBuffer = async (htmlContent, reportTitle) => {
    const fileName = `${reportTitle.replace(/\s/g, '_')}_${Date.now()}.pdf`;

    let browser; 

    try {
        // Launch Puppeteer with increased timeout and stable arguments
        browser = await puppeteer.launch({ 
            headless: 'new',
            // Increased timeout for launch stabilization
            timeout: 60000, 
            args: [
                '--no-sandbox', 
                '--disable-setuid-sandbox',
                '--disable-dev-shm-usage', 
            ]
        });
        
        const page = await browser.newPage();
        
        // FIX: Changed waitUntil to 'domcontentloaded' and increased timeout to prevent rendering timeout error
        await page.setContent(htmlContent, { 
            waitUntil: 'domcontentloaded', // Waits only for DOM parsing, ignoring network resources
            timeout: 60000 // Increased timeout to 60 seconds
        }); 
        
        const pdfBuffer = await page.pdf({ 
            format: 'A4', 
            printBackground: true, 
            margin: { top: '1cm', right: '1cm', bottom: '1cm', left: '1cm' }
        });
        
        await browser.close(); 
        
        return { buffer: pdfBuffer, fileName };

    } catch (error) {
        console.error("Puppeteer PDF Generation Failed:", error);
        
        // Ensure the browser is closed even on failure to free up resources
        if (browser) {
            await browser.close().catch(e => console.error("Failed to close browser after crash:", e));
        }

        // Throw a controlled error message for the controller to handle
        throw new Error('Failed to generate PDF report due to server processing error. Check server resources.');
    }
};


// Gets strategic report data, generates the PDF buffer, and returns it.
export const generateTBPublicHealthReportService = async (filters = {}) => {
    const { startDate, endDate } = filters;
    const dateFilter = {};
    if (startDate || endDate) {
        if (startDate) dateFilter.$gte = new Date(startDate);
        if (endDate) dateFilter.$lte = new Date(endDate);
    }
    
    // Aggregations for strategic decision-making
    const outcomeReport = await Patient.aggregate([
        { $match: { createdAt: dateFilter, finalTreatmentOutcome: { $exists: true, $ne: null } } },
        { $group: { _id: '$finalTreatmentOutcome', count: { $sum: 1 } } }
    ]);

    const notificationTrend = await Patient.aggregate([
        { $match: { createdAt: dateFilter } }, 
        { 
            $group: {
                _id: { 
                    year: { $year: '$createdAt' },
                    quarter: { $ceil: { $divide: [{ $month: '$createdAt' }, 3] } }
                },
                count: { $sum: 1 }
            }
        },
        { $sort: { '_id.year': 1, '_id.quarter': 1 } }
    ]);

    const relapseCount = await Patient.countDocuments({ 
        createdAt: dateFilter, 
        isRelapseCase: true 
    });

    const reportData = {
        TSR_Analysis: outcomeReport,
        Notification_Trend: notificationTrend,
        Relapse_Count: relapseCount,
    };

    const htmlContent = createReportHtml(reportData, filters);
    const { buffer, fileName } = await generatePDFBuffer(htmlContent, 'Quarterly_Public_Health_Report');
    
    return { reportData, buffer, fileName }; 
};


// Existing operational services:

export const getTrendsService = async (period = 'month') => {
    const groupFormat = period === 'week' ? { $week: '$createdAt' } : { $month: '$createdAt' };

    const newPatientsTrend = await Patient.aggregate([
        { $group: { _id: groupFormat, count: { $sum: 1 } } },
        { $sort: { _id: 1 } }
    ]);

    const treatmentsTrend = await Treatment.aggregate([
        { $group: { _id: groupFormat, count: { $sum: 1 } } },
        { $sort: { _id: 1 } }
    ]);

    const labPosTrend = await LabTest.aggregate([
        { $match: { 'geneXpert.mtbDetected': 'detected' } },
        { $group: { _id: groupFormat, count: { $sum: 1 } } },
        { $sort: { _id: 1 } }
    ]);

    return { period, data: { newPatientsTrend, treatmentsTrend, labPosTrend } };
};

export const getDashboardDataService = async (filters = {}) => {
    const { startDate, endDate, treatmentPhase, patientStatus } = filters;

    const patientQuery = {};
    if (patientStatus) patientQuery.treatmentStatus = patientStatus;
    if (startDate || endDate) {
        patientQuery.createdAt = {};
        if (startDate) patientQuery.createdAt.$gte = new Date(startDate);
        if (endDate) patientQuery.createdAt.$lte = new Date(endDate);
    }

    const treatmentQuery = {};
    if (treatmentPhase) treatmentQuery.phase = treatmentPhase;
    if (startDate || endDate) {
        treatmentQuery.createdAt = {};
        if (startDate) treatmentQuery.createdAt.$gte = new Date(startDate);
        if (endDate) treatmentQuery.createdAt.$lte = new Date(endDate);
    }

    const totalPatients = await Patient.countDocuments(patientQuery);
    const activePatients = await Patient.countDocuments({ ...patientQuery, treatmentStatus: 'ongoing' });
    const completedPatients = await Patient.countDocuments({ ...patientQuery, treatmentStatus: 'completed' });
    const defaultedPatients = await Patient.countDocuments({ ...patientQuery, treatmentStatus: 'defaulted' });

    const totalTreatments = await Treatment.countDocuments(treatmentQuery);
    const ongoingTreatments = await Treatment.countDocuments({ ...treatmentQuery, status: 'ongoing' });
    const completedTreatments = await Treatment.countDocuments({ ...treatmentQuery, status: 'completed' });
    const failedTreatments = await Treatment.countDocuments({ ...treatmentQuery, status: 'failed' });

    const totalTests = await LabTest.countDocuments();
    const completedTests = await LabTest.countDocuments({ status: 'completed' });
    const positiveGeneXpert = await LabTest.countDocuments({ 'geneXpert.mtbDetected': 'detected' });
    const positiveSmear = await LabTest.countDocuments({ 'smear.result': 'positive' });

    return {
        filters,
        data: {
            patients: { totalPatients, activePatients, completedPatients, defaultedPatients },
            treatments: { totalTreatments, ongoingTreatments, completedTreatments, failedTreatments },
            labTests: { totalTests, completedTests, positiveGeneXpert, positiveSmear },
        }
    };
};